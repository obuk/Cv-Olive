=encoding utf8

=head1 名前

Cv - 何かコンピュータビジョンでやってみるとき、あなたの助けになるように
(只今、書き直し中)

=head1 概要

 use Cv;
 
 my $image = Cv->LoadImage("/path/to/image");
 $image->ShowImage("image");
 Cv->WaitKey;
 
 my $capture = Cv->CaptureFromCAM(0);
 while (my $frame = $capture->QueryFrame) {
   $frame->Flip(\0, 1)->ShowImage;
   my $c = Cv->WaitKey(100);
   last if $c >= 0;
 }

=head1 説明

C<Cv> は OpenCV コンピュータビジョンライブラリの Perl インタフェースで
す。できるだけ OpenCV の C言語のリファレンスに合わせたので、基本的には
http://opencv.willowgarage.com/ の説明を参照してください。とは言え、異
なる部分もあるので、少しずつ文書にまとめています。

中途半端で申し訳ありません。

コンピュータビジョンは少し難しいので、Perl のスローガンに則り「簡単なこ
とは簡単に、難しいこともそれなりに」を心掛けています。

=head2 オブジェクト

=head3 オブジェクトの作成と解放

OpenCV の画像やマトリクスのオブジェクトは、C<Createなんとか()> を使って
作成します。

 my $img = Cv->CreateImage([ 320, 240 ], IPL_DEPTH_8U, 3);
 my $mat = Cv->CreateMat(240, 320, CV_8UC4);

オブジェクトを作るために C<new> も使えます。CreateImage() と
CreateMat() は、上の例のとおり呼び出し形式が違いますが。C<new> はどれも
同じです。

 my $arr = Cv::Image->new($size, $type);
 my $arr = Cv::Mat->new($size, $type);
 my $arr = Cv::MatND->new($size, $type);
 my $arr = Cv::SparseMat->new($size, $type);

オブジェクトを作るとき、元のオブジェクトがあれば引数を省略することがで
きます。そのとき指定しなかった引数は元のオブジェクトから引き継がれます。

 my $sameone = $img->new;
 my $gray = $color->new(CV_8UC1);

C言語のプログラムでは、画像やマトリクスを解放するとき、
C<cvReleaseImage()> を呼ばなければなりませんが、C<Cv> ではその必要はあ
りません、Perl がオブジェクトを解放するとき C<DESTROY> を呼ぶので、
C<DESTROY> を C<cvReleaseなんとか()> の別名として定義しています。

=head3 OpenCVのデータ型とCvのクラス名

OpenCV には C<CvImage>, C<CvMat>, C<CvMatND>, C<CvSparseMat> といった複
数のデータ型があり、クラス名は型名に対応しています。C<Cv> のオブジェク
トは、これらのデータのポインタを、単にクラス名で bless しただけのもので
す。

OpenCV には、いろいろな画像やマトリクスの型がありますが、これらは
C<CvArr*> を介して画像やマトリクスを操作する関数に渡さるように作られて
います。Cv も同様にスーパクラスとして C<Cv::Arr> を作り、メソッドは、こ
こに置きました。もちろん例外もありますが。

OpenCV には更にシーケンスと呼ばれる動的なデータ型もあります。これについ
ては、Cv::More を参照してください。

=head3 Perlの配列とOpenCVのマトリクス

Perl の配列から OpenCV のマトリクスを作るには、オブジェクトの作成時に、
その初期値として指定します。大きさは初期値から分るので、次のとおり書き
ます。(Cv-0.16)

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

要素が複数の値を持つ 2次元や、3次元の点の集りなら次のとおり書きます。こ
れは 3x1 の大きさのマトリクスです。

 my $pts = Cv::Mat->new([ ], CV_32FC3,
    [ $x0, $y0, $z0 ],
    [ $x1, $y1, $z1 ],
    [ $x2, $y2, $z2 ],
    );

=head3 データ領域の共有

(バージョンによって違いがあるのかな)

オブジェクトを作成するとき、データ領域を指定すると、Perl のデータに
OpenCV のヘッダを付加したり、ヘッダだけのオブジェクトが得られます。

 my $arr = Cv::Mat->new([length($data)], CV_8UC1, $data); # これはやめる
 my $arr = Cv::Mat->new([$rows, $cols], $type, undef);

前者は別のシステムで作成した画像やマトリクスを扱うとき、データ変換の手
間を減らせるかもしれないと考えたものですが、積極的には使っていません。
また残念ながら Cv::Image では動きません。後者は GetRows(), GetCols() の
ようなデータを共有するところで使っています。

=head3 OpenCVの構造体

構造体のメンバ名と同じ名前の関数を用意しました。

 my ($c, $d) = ($img->channels, $img->depth);
 my ($h, $w) = ($img->height, $img->width);
 my ($r, $c) = ($img->rows, $img->cols);
 my @sz = $img->sizes;

どのくらい作ったのかな、、、

=head2 メソッド

=head3 メソッドの名前、関数の統合

=item *

メソッドの名前は、OpenCV の関数名の頭の C<cv> を省いた名前と、名前のは
じめの大文字を小文字に直したものが使えます。次の 2つの例はどちらも
C<cvCreateMat()> を呼び出します。

 my $mat = Cv->CreateMat(240, 320, CV_8UC3);
 my $mat = Cv->createMat(240, 320, CV_8UC3);

=item *

C<cvAdd()> と C<cvAddS()> のような類似した関数は C<Add()>
にまとめました。関数は引数で区別できます。

 my $ar2 = Cv->CreateImage();      # ref Cv::Image
 my $sc2 = cvScalar();             # ref ARRAY
 my $d = $ar->Add($ar2);           # cvAdd($ar, $ar2)
 my $d = $ar->Add($sc2);           # cvAddS($ar, $sc2)

統合した関数は次のとおり。

 AbsDiff(), Add(), And(), Cmp(), InRange(), Max(), Min(), Or(), Sub(),
 Xor()

=head3 引数の順序、出力先、インプレース、戻り値

=item *

出力先の画像やマトリクス (C<dst> として表わされることが多い) が省略されたとき、
それが補える場合には補うようにしています。

 my $dst = $src->Add($src2);
 my $dst = $src->Add($src2, $mask);  # can't omit dst

この場合には、次のように $dst を作ります。

 my $dst = $src->Add($src2, $src->new, $mask); 

=item *

OpenCV は、インプレース処理が可能な関数では出力先の画像やマトリクス
C<dst> に C<NULL> を指定し、入力画像を出力先としても使います。
C<Cv> ではこの C<NULL> を表わすために C<\0> を使います。

 my $dst = $src->Flip(\0);


=head2 エラー処理

eval { ... } で保護したブロックの中のエラーを検出できるようになりました。
(Cv-0.13)

 my $img = eval { Cv->createImage([-1, -1], 8, 3) };
 if ($@) {
    print STDERR "*** got error ***";
 }

ただし、C<Cv> をインストールするとき、c++ でコンパイルしておく必要があります。
エラーを掴まえるだけでなく、自前で用意したエラー処理に向けることもできます。

 Cv->redirectError(
   sub { my ($status, $funcName, $errMsg, $fileName, $line, $data) = @_;
       ...
   },
   my $data = ...;
 );


=head2 Use Perl Array (これは Cv::More に移す)

OpenCV のシーケンスは、点、矩形、円など様々なデータを格納します。Perl
の配列に似ていますが、その取り扱いは少し難しいのです。そこで、格納され
たデータ型を意識せずに扱うスーパクラス Cv::Seq と、データ型に合わせて
pack/unpack で変換する派生クラス Cv::Seq::Point, Cv::Seq::Rect を作り、
データ型に合わせて bless して使うことにしました。C言語のキャストと同様
の使い方です。以下、facedetect の一部を示します。取り出されるシーケンス
は、Perl で扱いやすい形になります。

  my $faces = bless $image->HaarDetectObjects(
	$cascade, $storage, 1.1, 2, CV_HAAR_SCALE_IMAGE,
	cvSize(30, 30)), "Cv::Seq::Rect";
  while (my @rect = $faces->shift) {
    ...
  }

OpenCV のシーケンスは Perl の配列に似ているので、シーケンスを操作するた
めに、Push(), Pop(), Shift(), Unshift(), Splice() も用意しました。
点のシーケンス Cv::Seq::Point はよく使うので、new もあります。次の例は、
Perl の点の配列をシーケンスに直して MinEnclosingCircle() を呼びます。
$center と $radius が求まります。

 my @points = ([ 100, 100 ], [ 100, 200 ], [ 200, 100 ]);
 Cv::Seq::Point->new(&Cv::CV_32SC2)->push(@points)
	->minEnclosingCircle(my $center, my $radius);

同様に FitLine() でも Perl の配列を使うことができます。(Cv-0.15)

 Cv->FitLine(\@points, my $line);

ToArray() は、シーケンスを Perl の配列に変換します。次のコードは、
シーケンス $circles に格納されたすべての円を描きます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for $circles->toArray;

ToArray() でオーバライドされた @{} を使うと、もう少し簡単に書けます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for @$circles;


=head2 エクスポート

=over 4

=item *

Cv によってインポートされる名前は、use Cv の後に指定できます。(Cv-0.14)

次の 2行は、C<CV> や C<IPL> ではじまる定数やマクロと cvScalarAll()
のようないくつかの関数をインポートします。

 use Cv qw(:std);
 use Cv;			# 何も指定しないとき :std が補われる

次の 2行は、Cv のすべての名前をインポートします。

 use Cv qw(:all);
 use Cv qw(/^(CV|IPL|cv)/);

何もインポートしないときは、空のリストを続けます。

 use Cv qw( );

=back

=head1 ヒント

Cv を使っている方から、ちょっといい使い方を教えて戴きました。

=over 4

=item *

Cv で作成した画像を CGI で直接出力するとき、
EncodeImage() と Ptr() を使うことができます。
画像をファイルに保存する必要がありません。

 use Cv;
 my $img = Cv::Image->new([240, 320], CV_8UC3);
 $img->zero->circle([ 100, 100 ], 100, CV_RGB(255, 100, 100));
 print "Content-type: image/jpg\n\n";
 print $img->encodeImage(".jpg")->ptr;

これは Imager 向けの変換にも使えます。

 use Imager;
 my $imager = Imager->new(data => $img->encodeImage(".ppm")->ptr);

=item *

Perl のデータに Cv のヘッダを付けることができます。
行儀が良いとは言えませんが、
Cv で Perl のデータを直接操作できるようになります。

 my $data = pack("C*", 0 .. 255);
 my $mat = Cv::Mat->mew([16, 16], CV_8UC1, $data);
 substr($data, 0x41, 1) = 'x';
 print chr($mat->get([4, 1])->[0]), "\n";

=item *

C<Inline C> を使うためのコンフィギュレーションを用意しました。
これは、いろいろな実験や拡張を容易にしてくれます。
使い方は次のとおり簡単です。

 use Cv::Config;
 use Inline C => Config => %Cv::Config::C;

=back

=head1 サンプル

OpenCV に付属しているサンプルを、いくつか C<Cv> で書き直しました。
C<sample/> にあります。

=over 4

=item

 bgfg_codebook.pl calibration.pl camshiftdemo.pl capture.pl chamfer.pl
 contours.pl convexhull.pl delaunay.pl demhist.pl dft.pl distrans.pl
 drawing.pl edge.pl facedetect.pl fback_c.pl ffilldemo.pl find_obj.pl
 fitellipse.pl houghlines.pl image.pl imager.pl inpaint.pl kalman.pl
 kmeans.pl laplace.pl lkdemo.pl minarea.pl morphology.pl motempl.pl
 mser_sample.pl polar_transforms.pl pyramid_segmentation.pl squares.pl
 stereo_calib.pl stereo_match.pl tiehash.pl video-thread.pl
 watershed.pl

=back

=head1 バグ

=over 4

=item *

新しい定数が使いたくなったら C<Cv::Constant> に書かなければなりません。

=item *

バージョン 0.07 で名前付きの引数を諦めました。
名前付きの引数を処理するためのオーバヘッドが大きかったからです。
この版では C<Cv::TieHash> と C<Cv::TieArr> も削除しました。
C<Cv::TieHash> は C<sample/tiehash.pl> を参照してください。


=item *

バージョン 0.14 で別名を整理しました。
CV_MAKETYPE() のようなマクロのいくつかには Cv::MAKETYPE()
のような別名もありましたが、もとの名前の方が短いので、
別名を止めることにしました。

=item *

EncodeImage() は、2.4 では c のインタフェースが動かない。
c++ のコードを xs に展開したものでは動作する。(TBD)


=back

=head1 参考

http://sourceforge.net/projects/opencvlibrary/

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2010, 2011, 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
