# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - L<Cv|Cv::Nihongo> をもう少し Perl で使いやすくしたいね。

=head1 概要


=head1 説明

C<Cv::More> は、L<Cv|Cv::Nihongo> から実験的な機能を切り離して整理する
ためのパッケージです。C<Cv> が拡張しやすくなると考えています。
C<Cv::More> は、もともと C<Cv> の一部だったので、使わないことを明示しな
い限り C<Cv::More> も取り込まれます。

 use Cv;              # Cv::More を使う
 use Cv qw(:nomore);  # Cv::More を使わない

=head2 Perlの配列を使う

Perl で 2次元の点のリストは、おそらく次のようなものになるでしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV には、こうしたデータを処理する関数がいくつもあります。使用するに
は、このようなリストを OpenCV のマトリクスやシーケンスに変換しなければ
なりません。はじめはこのあたりから C<Cv> を使いやすくするということにつ
いて考えてみましょう。

=over

=item

点のリストを処理する関数は、次のドキュメンテーションの中に、いくつも見
付けられるでしょう。

L<http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html>

=back

=head3 Perlの配列でマトリクスを作る

上記の点のリスト C<@pts> をマトリクスのオブジェクトに変換するには、Nx1
のマトリクスを作り、要素を 1つずつ代入します。

 my $mat = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $mat->set([ 0, 0 ], [ $x0, $y0 ]);
 $mat->set([ 1, 0 ], [ $x1, $y1 ]);
 $mat->set([ 2, 0 ], [ $x2, $y2 ]);

これは、C<Cv::Mat-E<gt>new()> にオブジェクトの作成だけでなく、初期値を
設定する機能を持たせて、次のとおり 1つにまとめてしまいましょう。大きさ
は初期値から分ります。しかし、大きさを指定したくなりそうな気もするので、
省略 (初期値から得られる大きさを使うということ) を C<[ ]> で示すことに
しておきます。

 my $pts = Cv::Mat->new([ ], CV_32FC2,
    [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ],
    );

もうひとつ、大きさ 3x3、要素の型 C<CV_32FC1> のカメラマトリクスを作る例
を示します。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

書き方にもよりますが、代入文を並べるより直感的だと思います。この拡張は、
C<Cv::More> で C<Cv::Mat::new> を再定義して実験し、もし使いやすければ、
他のクラスへの適用も考えましょう。 XXXXX

=head3 マトリクスに要素を代入する

上の L</Perlの配列でマトリクスを作る> と同じように、次の 3x3 のマトリク
スの部分的な更新について考えましょう。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードは要素を 1つずつ代入します。 C<Cv> は、C言語のリファレンスを
そのまま実装したので、要素の代入しか出来ません。要素を修飾するマトリク
スのインデクスは、要素 C<$pts[0]>, C<$pts[1]>, C<$pts[2]> に合わせて
C<[ 2, 0 ]>, C<[ 2, 1 ]>, C<[ 2, 2 ]> になり、少々、冗長です。3行を
1行にまとめましょう。

 $mat->set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->set([ 2 ], \@pts);

すっきりしました。ただ、このインデクスを C<[ 2 ]> と書く省略した表現は、
実は、すでに C<Set()> において少し違う意味で使っています。いまの
C<Set()> は、省略したインデクスを単に 0で補います。これは、1次元のリス
トを 2次元の C<Cv::Mat> を Nx1 で使うので、いつも 0 になるインデクスが
できてしまうという問題の対処になっています。

 my $points = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $points->set([ 2 ], [ $x, $y ]);

というわけで、使いやすくしようとしたとき C<[ 2 ]> に C<[ 2, x ]> の要素
をまとめた代入先という意味と、C<[ 2, 0 ]> の 0 の省略という 2つの意味を
持たせることになります。これは C<Cv::Mat::new> を再定義する m_set() で、
詳細について考えましょう。

=head3 Perlの配列とOpenCVのシーケンス

OpenCV には多数の同じ要素を格納するマトリクスと異なる要素を格納するシー
ケンスというデータ構造があります。どちらでも点のリストは表現できます。
少し視点を変えて、OpenCV に用意されているシーケンスの利用について考えて
みましょう。(これはL<Cv::Seq|Cv::Seq-ja> へ)

=head3 マトリクスを Perl の配列に戻す

それでは次に OpenCV のデータを Perl の配列に変換する、戻すということに
ついて考えてみましょう。点を格納した Nx1 のマトリクスから順番に要素を取
り出すためのコードは次のとおり。

 for (my $i = 0; $i < $mat->rows; $i++) {
   my $x = $mat->get([$i, 0]);
   ...
 }

インデクス $i は要素を取り出す場面でしか使われないことが多いので、少し
工夫すれば次のとおり書くことができます。

 for ($mat->ToArray) {
     ...
 }

更に C<@{}> をオーバロードして C<ToArray()> を呼び出せるようにすれば、
Perl の点の配列を扱うところで利用者の負担を減らすことができます。たとえ
ば、点のリストを入力にする C<PolyLine()> では次のとおり。

 $img->polyLine([ [ @$mat ] ], ...); # もっと可能性があると思う。

=head2 メソッドに歩み寄ってもらう

ここまで Perl の配列と OpenCV のマトリクスとの間で、これらの変換を簡単
にするということについて考えました。これは、OpenCV の関数を使う側が、関
数の求めるものを用意するものでしたので、今度は、OpenCV の関数、すなわち
C<Cv> のメソッドに、Perl の点の配列を取り扱えないか、歩み寄ってもらえな
いか考えてみましょう。

=head3 C言語の面影かな

細部について考える前に、点のリストを入力にするメソッドを C<Cv> の実装か
ら集めてみましょう。

 my $rect = Cv->boundingRect(\@points, $update);
 Cv->fitLine(\@points, $dist_type, $param, $reps, $aeps, my $line);
 my $box = Cv->fitEllipse2(\@points);
 my $box = Cv->minAreaRect2(\@points);
 Cv->minEnclosingCircle(\@points, my $center, my $radius);
 my $s = Cv->ContourArea(\@points);

結果を引数で受けとる関数があるのは、結果が複数あるとき戻り値だけで済ま
なかったのでしょう。たとえば、C<MinEnclosingCircle()> は、 $center と
$radius の 2つを返したいが、できなかった。そういう感じです。これは、C言
語の戻り値の制約によるものですが、Perl はそうではありません。

 my $line = Cv->fitLine(\@points, $dist_type, $param, $reps, $aeps);
 my ($center, $radius) = Cv->minEnclosingCircle(\@points);

=head3 歩み寄りの歩み寄り

簡単に、使いやすく、という話は分りますが、いままでに作ったプログラムが
動かなくなるかもしれません。いや、きっと動かなくなるでしょう。迷惑な話
です。そう考えてあたりを見渡すと、Perl は wornings を使ってこのような問
題に対処しているように見えます。

たとえば、いままで MiAreaRect() は、呼び出されたコンテクストに関係なく、
いつでもスカラを返していました。サボってました。そこで、C<Cv::More> で
戻り値をコンテクストに合わせる変更を加えるとしましょう。すると、次のよ
うな場面で MinAreaRect() の呼出し側が影響を受けるのです。

  my @box = Cv->boxPoints(Cv->minAreaRect(\@points));         # いままで
  my @box = Cv->boxPoints(scalar Cv->minAreaRect(\@points));  # 変更の後

簡単にしようと思っていたのに、面倒くさいことになってしまいました。やは
りインターフェースの変更は厄介です。そこで、warnings を使って気にしてく
れたら、問題を知らせるだけでなく、いままでどおりリストコンテクストでも
スカラを返して、できるだけ同じ動作を保つことにしましょう。

  use warnings 'Cv::More::fashion';
  my @box = Cv->boxPoints(Cv->minAreaRect(\@points)); # 警告はあるが使える


 * 一方的なものではなく、うまいところはみつかるでしょうか。
 * 進めやすくするためには、心理的な制約を軽減するのもいい。

XXXXX

=head2 追加または拡張したメソッド

=over

=item FitEllipse2()

 my $box2d = Cv->FitEllipse2($points);

戻り値は CvBox2D です。リストコンテクストで呼ばれると、次のとおり要素が
展開されます。

 my ($center, $size, $angle) = Cv->FitEllipse2($points);

Perl のリストで表わした点と、それを FitEllipse2() で処理した結果を描き
表示するサンプルを示します。

 my $img = Cv::Image->new([250, 250], CV_8UC3)->fill(cvScalarAll(255));
 $img->origin(1);
 my @pts = (map { [ map { $_ / 4 + rand $_ / 2 } @{$img->size} ] } 1 .. 20);
 $img->circle($_, 3, &color, 1, CV_AA) for @pts;
 my $box = Cv->fitEllipse(\@pts);
 $img->polyLine([[Cv->boxPoints($box)]], -1, &color, 1, CV_AA);
 $img->ellipseBox($box, &color, 1, CV_AA);
 $img->show("FitEllipse2");
 Cv->waitKey;
 sub color { [ map { rand 255 } 1 .. 3 ] }

=item FitLine()

 my $line = Cv->FitLine($points, $dist_type, $param, $reps, $aeps);

たくさんパラメータがあります。しかし、$points 以外のパラメータは省略で
きます。入力 $points は、2次元の点または 3次元の点のリストです。結果は、
入力に合わせて変ります。

 my $points2d = [ [$x1, $y1], [$x2, $y2], ... ];
 my ($vx, $vy, $x0, $y0) = Cv->FitLine($points2d, ...);
 my $points3d = [ [$x1, $y1, $z1], [$x2, $y2, $z2], ... ];
 my ($vx, $vy, $vz, $x0, $y0, $z0) = Cv->FitLine($points3d, ...);

いくつかの点の集りにフィッティングさせた直線を描いてみましょう。

 my @pts = ([ 50, 50 ], [ 100, 120 ], [ 150, 150 ], [ 200, 150 ]);
 my ($vx, $vy, $x0, $y0) = Cv->fitLine(\@pts); 
 $img->line((map { [ $_, $vy / $vx * ($_ - $x0) + $y0 ] } 20, 230),
			cvScalarAll(200), 3, CV_AA);

サンプルのはじめと終りは C<FitEllipse2()> を参照してください。


=item MinAreaRect2()

 my $box2d = Cv->MinAreaRect2($points);
 my ($center, $size, $angle) = Cv->MinAreaRect2($points);

戻り値は CvBox2D です。FitEllipse2() と同じような結果を返しますが。重ね
合わせてみると違いが分ります。

 for ([ [ Cv->fitEllipse(\@pts)  ], [ 200, 200, 200 ] ],
      [ [ Cv->minAreaRect(\@pts) ], [ 100, 100, 255 ] ]) {
   $img->polyLine([[Cv->boxPoints($_->[0])]], -1, $_->[1], 1, CV_AA);
   $img->ellipseBox($_->[0], $_->[1], 1, CV_AA);
 }

サンプルのはじめと終りは C<FitEllipse2()> を参照してください。


=item MinEnclosingCircle()

 my $circle = Cv->MinEnclosingCircle($points);
 my ($center, $radius) = Cv->MinEnclosingCircle($points);

戻り値は、円の中心の座標 $center と半径 $radius です。CvBox2D の形に合
わせて重ね合わせてみましょう。

 my $rectangle = Cv->minAreaRect2(\@pts);
 my $ellipse = Cv->fitEllipse2(\@pts);
 my ($center, $radius) = Cv->minEnclosingCircle(\@pts);
 my $circle = [ $center, [ ($radius * 2) x 2 ], 0 ];
 for ([ $rectangle, [ 200, 200, 200 ] ],
      # [ $ellipse,   [ 200, 200, 200 ] ],
      [ $circle,    [ 100, 100, 255 ] ]) {
   $img->polyLine([[Cv->boxPoints($_->[0])]], -1, $_->[1], 1, CV_AA);
   $img->ellipseBox($_->[0], $_->[1], 1, CV_AA);
 }

サンプルで使った乱数による点のリストを処理してもあまり面白くないかもし
れませね。点が表わすものを C<FitEllipse2()>, C<FitLine()>,
C<MinAreaRect2()>, C<MinEnclosingCircle()> の中から元の形に合うものを選
ぶといいでしょう。サンプルはどれも似ているので、そのはじめと終りは
C<FitEllipse2()> から持って来てください。


=item BoundingRect()

 my $rect = Cv->BoundingRect($points)
 my ($x, $y, $width, $height) = Cv->BoundingRect($points)

点を囲む傾いていない矩形を求めます。傾いている矩形には
C<MinAreaRect2()> を使います。戻り値は CvRect なので、CvBox2D に直すと
C<EllipseBox()> や C<BoxPoints()> とのつながりが良くなります。
CvRect から CvBox2D への変換は次のとおり。

 my $box2d = [ [ $x + $width / 2, $y + $height / 2 ], [ $width, $height ], 0 ];


=item ToArray()


=item Cv::Arr::CvtMatToArray($arr)

 # @array = $arr->cvtMatToArray
 # $arr->cvtMatToArray(\@array)
 # @array = $arr->ToArray

=item Cv::Arr::ToArray($arr)

=item Cv::Seq::Point::CvtSeqToArray($seq)

 # @array = $seq->cvtSeqToArray
 # @array = $seq->cvtSeqToArray($slice)
 # $seq->cvtSeqToArray(\@array)
 # $seq->cvtSeqToArray(\@array, $slice)
 # @array = $seq->ToArray

=item Cv::Seq::Point::ToArray($seq)

=item Cv::ContourArea($points)

=item Cv::Arr::Affine()

=item Cv::GetBuildInformation()

=item Cv::HasModule()

=item Cv::Arr::m_new($size, $type, @init)

OpenCV の画像やマトリクスのオブジェクトは、大きさと要素の型を指定して作
ります。C<Cv::Createなんとか()> か C<Cv::なんとか::new()> で作ります。
C<m_new()> は、これらを再定義し、初期値を扱えるように拡張します。

 my $mat1 = Cv::Mat->new([], 要素の型, 初期値のリスト);
 my $mat2 = Cv::Mat->new(マトリクスの大きさ, 要素の型);
 my $mat3 = $mat->new();
 my $mat4 = $mat->new(マトリクスの大きさ);
 my $mat5 = $mat->new(要素の型);

C<m_new()> が拡張するのは、上の C<$mat1> を作る例です。マトリクスの大き
さを指定するところに C<[]> を指定します。具体的な使い方については、
L</Perlの配列でマトリクスを作る> を参照してください。他の例は、いまの
C<Cv> の C<new()> でできます。

初期値は、C<m_set()> で実装されています。制約もあるので詳細を確認してく
ださい。

=item Cv::Arr::m_set($mat, $index, $value)

マトリクスの要素、または要素のまとまりに値を代入します。 C<$index> で指
定されたマトリクスの要素の数と C<$value> で指定された要素の値の数のバラ
ンスがとれるように、C<$index> を補うか C<$value> をばらします。そして、
マトリクスの要素に値を 1つずつ代入します。

=over

=item *

代入される側、すなわちインデクスによる修飾は次のとおり。

 $mat->set([], $value);       # マトリクス $mat 全体
 $mat->set([$i], $value);     # マトリクス $mat の $i 行
 $mat->set([$i, $j], $value); # マトリクス $mat の $i 行 $j 列 

=back

 * 値の数が足りないとき代入を打ち切る。
 * m_set は set を再定義する。
 * m_set は失敗することがある。
 * m_ は Cv::more の〜 から。
 * ec は eval & croak くらい。

XXXXX

C<$mat> の要素を特定するために必要なインデクス (C<$mat> の添字) の数が、
C<$index> の指す配列に格納される要素の数と等しいなら C<$mat> の要素は特
定されたと考えられます。ただ、C<$value> については、C<$mat> の要素のチャ
ネル数が 1 のとき、たとえば C<CV_32FC1> のときにはリファレンスでない
C<$value> を使うことが考えられ、ここでリファレンスに直します。

 $value = [ $value ] unless ref $value;
 cvSetND($mat, $idx, $value)

しかし、こうして C<cvSetND()> を呼んだとき、誤りがあれば OpenCV がエラー
を発生させるでしょう。しかし C<m_set()> は下記のとおり再帰呼出しを使う
ので、エラーを補足するために呼出し側は C<eval { }> を使わなければなりま
せん。

上記の条件を満足しないとき、つまり、C<$mat> の要素を特定するために必要
なインデクスの数が足りないとき、もし C<$value> がネストした配列なら、足
りないインデクスを補って C<$value> の要素を 1つずつ C<m_set()> で再帰的
に処理します。

 $mat->m_set([@$idx, $_], $value->[$_]) for 0 .. $#{$value}

同様に、要素を特定するために必要なインデクスが足りないときは、
C<$value> がネストした配列ではなくても要素の数が 2以上だと混乱します。
もし C<$mat> の要素のチャネル数が 2 以上 (たとえば C<CV_32FC2> の類) な
ら、C<$value> の要素は個々のチャネルに対応するものかもしれないので、
Nx1 のマトリクスの最後のいつも 0 になるインデクス、つまり x1 の部分が省
略されたかもしれません。だから x2 以上で、要素のチャネル数が 1
(C<CV_32FC1> の類) のときにも、上と同様 C<$value> の要素を 1つずつ
C<m_set()> で再帰的に処理します。

それ以外は、最後のいつも 0 になるインデクスが省略された可能性がないか、
更に次のとおりインデクスに 0 を補い、再帰的な要素の更新を試みます。

 $mat->m_set([@$idx, 0], $value);

=back


=head1 バグ

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
