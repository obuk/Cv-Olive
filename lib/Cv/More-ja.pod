# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - L<Cv|Cv::Nihongo> をもう少し Perl で使いやすくしたいね。

=head1 概要


=head1 説明

C<Cv::More> は、L<Cv|Cv::Nihongo> から実験的な機能を切り離して整理する
ためのパッケージです。C<Cv> が拡張しやすくなると考えています。
C<Cv::More> は、もともと C<Cv> の一部だったので、次のとおり積極的に使わ
ないことを明示がない限り、C<Cv> を use 文で使ったとき、間接的に組み込
まれます。

 use Cv;              # Cv::More の拡張や実験を使う
 use Cv qw(:nomore);  # Cv::More を使わない

=head2 Perlの配列を使う

Perl で 2次元の点のリストは、おそらく次のようなものになるでしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV には、こうしたデータを処理する関数がいくつもあります。使用するに
は、OpenCV のマトリクスやシーケンスに変換しなければなりません。はじめは、
このあたりから C<Cv> を使いやすくするということについて考えてみましょう。

点のリストを処理する関数は、次のドキュメンテーションの中に、いくつも見
付けることができるでしょう。

=over

=item *

L<http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html>

=back

=head3 Perlの配列でマトリクスを作る

上記の点のリスト @pts をマトリクスのオブジェクトに変換するには、Nx1 の
マトリクスを作り、要素を 1つずつ代入します。

 my $mat = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $mat->set([ 0, 0 ], [ $x0, $y0 ]);
 $mat->set([ 1, 0 ], [ $x1, $y1 ]);
 $mat->set([ 2, 0 ], [ $x2, $y2 ]);

これは、Cv::Mat-E<gt>new に初期値を扱う機能を加えてまとめましょう。

 my $pts = Cv::Mat->new([ ], CV_32FC2,
    [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ],
    );

要素の型を指定する必要がありますが、大きさは初期値から分ります。C<[ ]>
で表わしましょう。もうひとつ、大きさ 3x3、要素の型 CV_32FC1 のカメラの
マトリクスを作ってみましょう。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

書くことが減るのもいいですが、直感的に書けるようになります。この拡張は、
C<Cv::Mat::new> を上書きする C<m_new()> で試し、もしうまく行ったら、他
のクラスにも適用することを考えようと思います。

=head3 マトリクスに要素を代入する

上の L</Perlの配列でマトリクスを作る> と同じように、次の 3x3 のマトリク
スの部分的な更新について考えてみましょう。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードにはインデクス [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] が並んでいます。
これはインデクスを [ 2 ] にして、値の方もまとめてしまいたいでしょう。

 $mat->set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->set([ 2 ], \@pts);

ただ、いまの set() は ptr() と同様、省略したインデクスを 0 で補います。
これは、Perl のリストを OpenCV のマトリクスに格納して使うとき、リストが
1次元の配列でしかないので、2次元のマトリクス C<Cv::Mat> を使うと Nx1 に
するしかありません。そうすると、いつも 0 になるインデクスが生じるのです。
そんなとき、省略して [$i] と書くのも仕方がないでしょう。元々 1次元の点
のリストだったことを思い出せば、インデクスは [$i, 0] より [$i] の方が自
然なものに見えるでしょう。皆さんは、どのように考えますか。

 my $points = Cv::Mat->new([3, 1], CV_32FC2);
 $points->set([$i], [$x, $y]);

私たちはいろいろな場面でそこに合った省略を使っており、決まっていること、
分っていることは、それを省略できる場面ではそうしています。しかし、もう
一方において、このような曖昧な表現が間違いを見付けにくくすることも経験
しており、こうした考え方には消極的なところもあります。これは、後でこの
パッケージを use したときに再定義される C<Cv::Arr> の m_set() において、
もう少し正確に定義することにしましょう。

=head3 Perlの配列とOpenCVのシーケンス

OpenCV には多数の同じ要素を格納するマトリクスと異なる要素を格納するシー
ケンスというデータ構造があります。どちらを使っても点のリストを表現でき
るます。マトリクスを使った点のリストは上の例にあるので、少し視点を変え
て、シーケンスの方から考えてみましょう。

=head3 OpenCV の便利な機能を使う

(ぐだぐだ)

点のリストを格納したシーケンスやマトリクスを入力にする関数を OpenCV の
ドキュメンテーションの中に見付けることができます。上記のドキュメンテー
ションから拾うと、

 cvApproxPoly(): 点のシーケンス
 cvArcLength(): 点のシーケンス、または配列
 cvBoundingRect(): 点のシーケンス、またはマトリクス
 cvCheckContourConvexity(): 点のシーケンス、または配列
 cvContourArea(): 点のシーケンス、または配列
 cvConvexHull2(): 点のシーケンス、または配列
 cvConvexityDefects(): 点のシーケンス、またはマトリクス
 ...

たくさんある。さて、どうするか。

次の例は、Perl の点の配列をシーケンスに直し MinEnclosingCircle() を呼び、
そして$center と $radius を求めます。

 my @points = ([ 100, 100 ], [ 100, 200 ], [ 200, 100 ]);
 Cv::Seq::Point->new(&Cv::CV_32SC2)->push(@points)
	->minEnclosingCircle(my $center, my $radius);

C<Cv:More> はこのようなコードを加えることで、次のとおり、Perl の配列を
そのまま入力として扱えるようにします。

 Cv->minEnclosingCircle(\@points, my $center, my $radius);

上のコードは、点のリストをマトリクスに格納して、次のとおり書くこともで
きます。

 Cv::Mat->new([], &Cv::CV_32SC2, [ 100, 100 ], [ 100, 200 ], [ 200, 100 ])
    ->minEnclosingCircle(my $center, my $radius);

マトリクスよりシーケンスの方が Perl のリストに似ています。シーケンスを
操作する関数の名前も Perl に似ています。従って、これらの整合は悪くない
でしょう。OpenCV の関数の中にはマトリクスとシーケンスの両方とも扱う関数
がいくつもあります。どちらでもいいところでは、簡単な実装を選ぶことにし
ましょうか。

=head3 マトリクスやシーケンスを Perl の配列にする

OpenCV のデータを Perl の配列に変換する場面を考えてみましょう。点を格納
した Nx1 のマトリクスから順番に要素を取り出すためのコードは次のとおり
書くことができます。

 for (my $i = 0; $i < $mat->rows; $i++) {
   my $x = $mat->get([$i, 0]);
   ...
 }

同様にシーケンスから要素を取り出すためのコードは次のとおり。 2つは良く
似ています。

 for (my $i = 0; $i < seq->total; $i++) {
     my $x = $seq->get($i);
     ...
 }

どちらのコードでもインデクス $i は要素を取り出す場面でしか使われないこ
とが多いので、少し工夫すれば次のとおり書けるでしょう。

 for ($seq_or_mat->ToArray) {
     ...
 }

これは、更に @{} をオーバロードして、ToArray() が呼ばれるようにすれば、
もっと簡単になります。たとえば、polyLine() に点のリストを引数として渡す
場面をすっきりさせられます。

 $img->polyLine([ [ @$seq_or_mat ] ], -1, ...);


=head2 追加または拡張したメソッド

=over

=item Cv::Arr::m_new($size, $type, @init)

OpenCV の画像やマトリクスのオブジェクトは、大きさと要素の型を指定して作
ります。C<Cv::Createなんとか()> または C<Cv::なんとか::new()> で作成で
きます。C<m_new()> は、それを再定義し、初期値を扱えるように拡張します。

 my $mat1 = Cv::Mat->new([], 要素の型, 初期値のリスト);
 my $mat2 = Cv::Mat->new(マトリクスの大きさ, 要素の型);
 my $mat3 = $mat->new();
 my $mat4 = $mat->new(マトリクスの大きさ);
 my $mat5 = $mat->new(要素の型);

C<m_new()> が拡張するのは、上の $mat1 を作る例です。マトリクスの大きさ
を指定するところでに C<[]> を指定します。具体的な使い方については、
L</Perlの配列でマトリクスを作る>を参照してください。他の例はどれも
C<Cv>に含まれる C<new()> でも実現できます。初期値は、C<m_set()> で実装
されています。制約もあるので詳細を確認してください。

いまのところ作成できるオブジェクトは C<Cv::Mat> に限りますが、うまく行っ
たら他のオブジェクトもと考えています。

=item Cv::Arr::m_set($mat, $index, $value)

$mat の要素を特定するために必要なインデクス ($mat の添字) の数が、
$index の指すインデクスの配列に格納される素数の数と等しいなら $mat の要
素は特定されたと考えられます。ただ、$value については、$mat の要素のチャ
ネル数が 1 のとき、つまり CV_32FC1 の類のときにはリファレンスでない
$value を使う可能性があるので、ここでリファレンスに直しておきます。

 $value = [ $value ] unless ref $value;
 cvSetND($mat, $idx, $value)

しかし、こうして cvSetND() を呼んだとき、誤りがあれば OpenCV がエラーを
発生させることが想定されますが、m_set() には下記の条件で再帰呼出しを使
う必要があるので、いまのところ呼出し側で、eval {} を使ってエラーを補足
するコードが必要になります。

上記の条件を満足しないとき、つまり、$mat の要素を特定するために必要にな
るインデクスの数が足りないとき、$value がネストした配列のリファレンスな
ら、足りないインデクスを補い、$value に格納される要素を 1つずつ
m_set() を呼んで再帰的に処理します。

 $mat->m_set([@$idx, $_], $value->[$_]) for 0 .. $#{$value}

同様に、要素を特定するために必要なインデクスが足りないときは、$value が
ネストした配列ではなくても要素の数が 2以上だと混乱します。 もし $mat の
要素のチャネル数が 2 以上 (たとえば CV_32FC2 の類) なら、$value の要素
は個々のチャネルに対応するものかもしれないので、Nx1 のマトリクスの最後
のいつも 0 になるインデクス、つまり x1 の部分が省略されたかもしれません。
だから x2 以上で、要素のチャネル数が 1 (CV_32FC1 の類) のときには、上と
同様 $value の要素を 1つずつ m_set() で再帰的に処理します。

それ以外は、最後のいつも 0 になるインデクスが省略された可能性がないか、
更に次のとおりインデクスに 0 を補い、再帰的な要素の更新を試みます。

 $mat->m_set([@$idx, 0], $value);

=item Cv::GetBuildInformation()

=item Cv::HasModule()

=item Cv::Arr::CvtMatToArray($arr)

 # @array = $arr->cvtMatToArray
 # $arr->cvtMatToArray(\@array)
 # @array = $arr->ToArray

=item Cv::Arr::ToArray($arr)

=item Cv::Seq::Point::CvtSeqToArray($seq)

 # @array = $seq->cvtSeqToArray
 # @array = $seq->cvtSeqToArray($slice)
 # $seq->cvtSeqToArray(\@array)
 # $seq->cvtSeqToArray(\@array, $slice)
 # @array = $seq->ToArray

=item Cv::Seq::Point::ToArray($seq)

=item Cv::FitLine($points, $dist_type, $param, $reps, $aeps, $line)

 # cvFitLine(points, dist_type, param, reps, aeps, line)

=item Cv::FitEllipse2($points)

=item Cv::MinAreaRect2($points)

=item Cv::MinEnclosingCircle($points)

=item Cv::ContourArea($points)

=item Cv::Arr::Affine()

=back


=head1 バグ

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
