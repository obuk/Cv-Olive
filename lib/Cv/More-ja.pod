# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - Cv をもう少し Perl で使いやすくする。

=head1 概要


=head1 説明

C<Cv::More> は、C<Cv> をもう少し Perl で使いやすくするために、拡張や実
験的なコードを納めるためのパッケージです。

=head2 Perlの配列を使う

Perl の配列は柔軟です。だから Perl の配列で OpenCV のデータを表わしたく
なります。たとえば、2次元の点のリストは次のとおり書くのが自然でしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV はこのような点のリストをマトリクスやシーケンスのデータ型に格納し
て使いますが、Perl のデータと OpenCV のデータを相互に変換するのはあまり
簡単ではありません。もう少し使いやすくしてみましょう。

=head3 Perlの配列でマトリクスを作る

上の 2次元の点のリスト @pts をマトリクスのオブジェクトにしようとしたら、
次のとおり同じようなコードを繰り返し書くことになります。

 my $mat = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $mat->set([ 0, 0 ], [ $x0, $y0 ]);
 $mat->set([ 1, 0 ], [ $x1, $y1 ]);
 $mat->set([ 2, 0 ], [ $x2, $y2 ]);

これは、Cv::Mat-E<gt>new に初期値を与えられるようにすると、次のとおり
小さくできます。

 my $pts = Cv::Mat->new([ ], CV_32FC2,
    [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ],
    );

要素の型は指定するしかありません。しかし、大きさは初期値から分るので、
[ ] と書いておきます。

次の例は。大きさ 3x3、要素の型 CV_32FC1 のカメラのマトリクスを作ります。
もし Cv::Mat-E<gt>new が初期値を受け入れないとしたら、要素の代入が 9つ
並びます。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

マトリクスの行と列の数を数えなくていい。個々の要素の代入文を書かなくて
いい。書くことが減るとその分だけ楽ができます。

=head3 マトリクスに要素を代入する

上の L</Perlの配列でマトリクスを作る> と同じように、次の 3x3 のマトリク
スの部分的な更新を考えてみましょう。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードにはインデクス [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] が並びます。これ
は [ 2 ] と書いて値をまとめてしまうのが良いでしょう。

 $mat->m_set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->m_set([ 2 ], \@pts);

いまのところ、set() を拡張せず、m_set() という別の名前を使っていますが、
後で、set() を拡張して統合しようと思います。しかし、統合するとき気にな
ることもあります。

=head4 set() と m_set() の統合で気になること (メモ)

いまの set() は ptr() に合わせてインデクスの省略を単に 0 として扱ってい
ます。これは単に不足する引数を補うものですが、リストをマトリクスに格納
して使うとき、この省略が都合良く働いています。

リストは 1次元の配列ですから、2次元のマトリクスに格納するとき Nx1 にな
ります。Nx1 のマトリクスにはいつも 0 になるインデクスがあります。いつも
0 のインデクスであっても指定しなければ誤りかもしれませんが、それでは少
し窮屈な感じがします。次の例のように、 set()のインデクスとして [$i, 0]
を [$i] を書いても要素は特定できます。省略したところに補われる 0 は、こ
のような意味で働きます。

 my $points = Cv::Mat->new([3, 1], CV_32FC2);
 $points->set([$i], [$x, $y]);

私たちはいろいろな場面でその場面に合った省略を使っており、決まっている
こと、分っていることは、それを省略できる場面ではそうします。しかし、こ
のような曖昧な使い方は間違いを見付けにくくするというオマケもあるなあと
思うこともあります。

=head3 Perlの配列とOpenCVのシーケンス

OpenCV には多数の同じ要素を格納するマトリクスというデータ構造があります
が、異なる要素を格納するためにシーケンスというデータ構造もあります。

OpenCV のシーケンスは、点、矩形、円など様々なデータを格納します。Perl
の配列に似ていますが、柔軟な分だけ、その取り扱いは少し難しいと思います。
そこで、格納されたデータ型を意識せずに扱うスーパクラス Cv::Seq と、デー
タ型に合わせた変換を行う派生クラス Cv::Seq::Point, Cv::Seq::Rect を作り、
データ型に合わせて bless して使おうと考えました。C言語のキャストのよう
な使い方です。

いろいろなものを格納する Cv::Seq のデータは、Perl では文字列で表わし、
派生クラスはその文字列を pack/unpack で Perl の配列に変換するという分
担です。

=head3 HaarDetectObjects() を使う

はじめに facedetect の一部を示します。HaarDetectObjects() は、顔を示す
領域として複数の CvRect を格納したリストをシーケンスで返します。例は、
シーケンスを C<Cv::Seq::Rect> で bless し、Perl の配列にして 1つずつ顔
を取り出します。

  my $faces = bless $image->HaarDetectObjects(
    $cascade, $storage, 1.1, 2, CV_HAAR_SCALE_IMAGE,
    cvSize(30, 30)), "Cv::Seq::Rect";
  while (my @rect = $faces->shift) {
    my ($x, $y, $w, $h) = @rect;
    ...
  }

同じ部分を C言語で書いたものを並べておきます。見比べやすくするために、
少し余分なものを省きました。

  CvSeq* faces = cvHaarDetectObjects(
    image, cascade, storage, 1.1, 2, CV_HAAR_SCALE_IMAGE,
    cvSize(30, 30));
  for (;;) {
    CvRect rect;
    cvSeqPopFront(faces, &rect);
    ...
  }

OpenCV のシーケンスは Perl の配列に似ており、シーケンスを操作するために
cvSeqPush(), cvSeqPop(), cvSeqPopFront(), cvSeqPushFront() という関数が
あります。これらは Perl の push, pop, shift, unshift を連想させるので、
少し名前を変えて使っています。詳細は、L</メソッド>を参照してください。

=head3 MinEnclosingCircle() を使う

minEnclosingCircle() だけでなく、FitLine()、ContourArea() も同様ですが、
これらは入力に点のリストを格納したシーケンスかマトリクスを入力にします。
次の例は、Perl の点の配列をシーケンスに直し MinEnclosingCircle() を呼び、
$center と $radius を求めます。

 my @points = ([ 100, 100 ], [ 100, 200 ], [ 200, 100 ]);
 Cv::Seq::Point->new(&Cv::CV_32SC2)->push(@points)
	->minEnclosingCircle(my $center, my $radius);

そう大きなコードではありませんが、C<Cv> ではこのようなコードをひとまと
めにして、次のとおり、直接 Perl の配列を入力として与えられるようにして
います。

 Cv->minEnclosingCircle(\@points, my $center, my $radius);

点のリストはマトリクスにも格納できるので、次のとおり書くこともできます。

 Cv::Mat->new([], &Cv::CV_32SC2, [ 100, 100 ], [ 100, 200 ], [ 200, 100 ])
    ->minEnclosingCircle(my $center, my $radius);

マトリクスよりシーケンスの方が Perl のリストに似ており、シーケンスを操
作する関数の名前も Perl に似ています。従って、これらの整合は悪くないと
思います。OpenCV の関数の中にはマトリクスとシーケンスの両方を扱ってくれ
る関数がいくつもあります。

ただ、いまの C<Cv> の実装では、処理時間についてはマトリクスに分があり、
途中でデータの大きさを変えることがないなら、シーケンスでなくマトリクス
でも十分かもしれません。そんなわけで、C<Cv> では、どちらの実装にしよう
か、少し迷っており、しばらく 2つの実装を比べてみて、それから考えようと
思っています。

=head3 Perl の配列に戻す

ToArray() は、シーケンスを Perl の配列に変換します。次のコードは、
シーケンス $circles に格納されているすべての円を描きます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for $circles->toArray;

C<Cv::Seq::Point::ToArray> は点が格納されたシーケンスを、Perl の配列に
戻します。C<Cv::Seq::Point> は C<Cv::Seq::Rect> や C<Cv::Seq::Circle>
のスーパクラスなので、同様に Perl の配列を得ることができます。
C<Cv::Arr::ToArray> は、Nx1 か 1xN のマトリクスに格納した点のリストを
戻します。

この ToArray は、overoad によって @{} から呼ばれるので、上の例はもう少
し簡単に書けます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for @$circles;

=head1 バグ

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
