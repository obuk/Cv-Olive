# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - L<Cv|Cv::Nihongo> をもう少し Perl で使いやすくしたいね。

=head1 概要


=head1 説明

C<Cv::More> は、L<Cv|Cv::Nihongo> から実験的な機能を切り離して整理する
ためのパッケージです。C<Cv> が拡張しやすくなると考えています。
C<Cv::More> は、もともと C<Cv> の一部だったので、次のとおり積極的に使わ
ないことを明示しない限り、C<Cv> を use 文で使ったときに C<Cv::More> も
間接的に取り込まれます。

 use Cv;              # Cv::More の拡張や実験も使う
 use Cv qw(:nomore);  # Cv::More を使わない

=head2 Perlの配列を使う

Perl で 2次元の点のリストは、おそらく次のようなものになるでしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV には、こうしたデータを処理する関数がいくつもあります。使用するに
は、OpenCV のマトリクスやシーケンスに変換しなければなりません。はじめは、
このあたりから C<Cv> を使いやすくするということについて考えましょう。

=over

=item

点のリストを処理する関数は、次のドキュメンテーションの中に、いくつも見
付けられるでしょう。

L<http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html>

=back

=head3 Perlの配列でマトリクスを作る

上記の点のリスト C<@pts> をマトリクスのオブジェクトに変換するには、Nx1
のマトリクスを作り、要素を 1つずつ代入します。

 my $mat = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $mat->set([ 0, 0 ], [ $x0, $y0 ]);
 $mat->set([ 1, 0 ], [ $x1, $y1 ]);
 $mat->set([ 2, 0 ], [ $x2, $y2 ]);

これは、C<Cv::Mat-E<gt>new()> にオブジェクトの作成だけでなく、初期値を
設定する機能を持たせて、次のとおり 1つにまとめられます。大きさは初期値
から分ります。大きさを省略する (初期値から得られる大きさを使う) という
ことを C<[ ]> で表わすことにしましょう。

 my $pts = Cv::Mat->new([ ], CV_32FC2,
    [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ],
    );

もうひとつ、大きさ 3x3、要素の型 C<CV_32FC1> のカメラマトリクスを作る例
を示します。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

書き方にも依りますが、直感的だと思います。この拡張は、C<Cv::Mat::new>
を上書きする C<m_new()> で試し、もしうまく行ったら他のクラスへの適用も
考えましょう。

=head3 マトリクスに要素を代入する

上の L</Perlの配列でマトリクスを作る> と同じように、次の 3x3 のマトリク
スの部分的な更新について考えましょう。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードは要素を 1つずつ代入しており、インデクス C<[ 2, 0 ]>, C<[ 2,
1 ]>, C<[ 2, 2 ]> と値 C<$pts[0]>, C<$pts[1]>, C<$pts[2]> をバラで使っ
ています。3行を1行にまとめましょう。

 $mat->set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->set([ 2 ], \@pts);

すっきりしました。ただ、このインデクス C<[ 2 ]> は、いまの C<Cv> の
C<Set()> が少し違う意味で使っています。

いまの C<Cv> の C<Set()> は、C<Ptr()> と同様に省略されたインデクスに 0
を補います。これは、1次元のリストを 2次元の Nx1 のマトリクス
C<Cv::Mat> に格納したとき、いつも 0 になるインデクスを省き C<[ 2, 0 ]>
を C<[ 2 ]> と書けるようにしています。

 my $points = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $points->set([ 2 ], [ $x, $y ]);

つまり C<[ 2 ]> には、C<[ 2, x ]> をまとめたものと C<[ 2, 0 ]> を省略し
たものの意味があります。従って、インデクスの意味を解釈するには、場面
(文脈) の参照も必要になります。

=over

=item

私たちはいろいろな場面でそこに合った省略を使っており、決まっていること、
分っていることは、それを省略できる場面ではそうしています。しかし、もう
一方において、このような曖昧な表現が間違いを見付けにくくすることも経験
しています。これは、後でこのパッケージを use したときに再定義される
C<Cv::Arr> の m_set() において、もう少し正確に定義しましょう。

=back

=head3 Perlの配列とOpenCVのシーケンス

OpenCV には多数の同じ要素を格納するマトリクスと異なる要素を格納するシー
ケンスというデータ構造があります。どちらを使っても点のリストを表現でき
るます。マトリクスを使った点のリストは上の例で議論したので、少し視点を
変えて、シーケンスの方から考えてみましょう。(これは
L<Cv::Seq|Cv::Seq-ja> へ)

=head3 マトリクスやシーケンスを Perl の配列にする

OpenCV のデータを Perl の配列に変換する場面を考えましょう。点を格納した
Nx1 のマトリクスから順番に要素を取り出すためのコードは次のとおり書くこ
とができます。

 for (my $i = 0; $i < $mat->rows; $i++) {
   my $x = $mat->get([$i, 0]);
   ...
 }

インデクス $i は要素を取り出す場面でしか使われないことが多いので、少し
工夫すれば次のとおり書けます。

 for ($mat->ToArray) {
     ...
 }

これは、更に C<@{}> をオーバロードして、C<ToArray()> が呼ばれるようにす
れば、もっと簡単になります。たとえば、C<polyLine()> に点のリストを渡す
場面は次のとおり。

 $img->polyLine([ [ @$mat ] ], -1, ...);

=head2 引数と戻り値を揃える

L</Perlの配列を使う> では Perl の配列と OpenCV のマトリクスの変換を楽に
しようと試みました。次は、C<Cv> のメソッドを拡張し、Perl の配列を渡せ
るようなメソッドの拡張や追加について考えましょう。

=head3 点の配列を入力にするメソッド

点のリストを入力にするメソッドを C<Cv> の実装から集めて、入出力を揃えま
しょう。

 my $rect = Cv->boundingRect(\@points, $update);
 Cv->fitLine(\@points, $dist_type, $param, $reps, $aeps, my $line);
 my $box = Cv->fitEllipse2(\@points);
 my $box = Cv->minAreaRect2(\@points);
 Cv->minEnclosingCircle(\@points, my $center, my $radius);
 my $s = Cv->ContourArea(\@points);

C<MinEnclosingCircle()> のように複数の結果を返すものもありますが、基本
的には次の形式に集約できます。

 my $retval = Cv->method(\@points, @parameters, my $results);

=over

=item *

課題もある。過去のインターフェースとの互換性。

=item *

実装は、 C<Cv::Arr::FitLine()> と C<Cv::FitLine()> の 2つに分けて。

=back

=head2 追加または拡張したメソッド

=over

=item Cv::Arr::m_new($size, $type, @init)

OpenCV の画像やマトリクスのオブジェクトは、大きさと要素の型を指定して作
ります。C<Cv::Createなんとか()> か C<Cv::なんとか::new()> で作ります。
C<m_new()> は、これらを再定義し、初期値を扱えるように拡張します。

 my $mat1 = Cv::Mat->new([], 要素の型, 初期値のリスト);
 my $mat2 = Cv::Mat->new(マトリクスの大きさ, 要素の型);
 my $mat3 = $mat->new();
 my $mat4 = $mat->new(マトリクスの大きさ);
 my $mat5 = $mat->new(要素の型);

C<m_new()> が拡張するのは、上の C<$mat1> を作る例です。マトリクスの大き
さを指定するところに C<[]> を指定します。具体的な使い方については、
L</Perlの配列でマトリクスを作る> を参照してください。他の例は、いまの
C<Cv> の C<new()> でできます。

初期値は、C<m_set()> で実装されています。制約もあるので詳細を確認してく
ださい。

=item Cv::Arr::m_set($mat, $index, $value)

C<$mat> の要素を特定するために必要なインデクス (C<$mat> の添字) の数が、
C<$index> の指す配列に格納される要素の数と等しいなら C<$mat> の要素は特
定されたと考えられます。ただ、C<$value> については、C<$mat> の要素のチャ
ネル数が 1 のとき、たとえば C<CV_32FC1> のときにはリファレンスでない
C<$value> を使うことが考えられ、ここでリファレンスに直します。

 $value = [ $value ] unless ref $value;
 cvSetND($mat, $idx, $value)

しかし、こうして C<cvSetND()> を呼んだとき、誤りがあれば OpenCV がエラー
を発生させるでしょう。しかし C<m_set()> は下記のとおり再帰呼出しを使う
ので、エラーを補足するために呼出し側は C<eval { }> を使わなければなりま
せん。

上記の条件を満足しないとき、つまり、C<$mat> の要素を特定するために必要
なインデクスの数が足りないとき、もし C<$value> がネストした配列なら、足
りないインデクスを補って C<$value> の要素を 1つずつ C<m_set()> で再帰的
に処理します。

 $mat->m_set([@$idx, $_], $value->[$_]) for 0 .. $#{$value}

同様に、要素を特定するために必要なインデクスが足りないときは、
C<$value> がネストした配列ではなくても要素の数が 2以上だと混乱します。
もし C<$mat> の要素のチャネル数が 2 以上 (たとえば C<CV_32FC2> の類) な
ら、C<$value> の要素は個々のチャネルに対応するものかもしれないので、
Nx1 のマトリクスの最後のいつも 0 になるインデクス、つまり x1 の部分が省
略されたかもしれません。だから x2 以上で、要素のチャネル数が 1
(C<CV_32FC1> の類) のときにも、上と同様 C<$value> の要素を 1つずつ
C<m_set()> で再帰的に処理します。

それ以外は、最後のいつも 0 になるインデクスが省略された可能性がないか、
更に次のとおりインデクスに 0 を補い、再帰的な要素の更新を試みます。

 $mat->m_set([@$idx, 0], $value);

=item Cv::FitLine($points, $dist_type, $param, $reps, $aeps, $line)

=item Cv::Arr::FitLine($points, $dist_type = CV_DIST_L2, $param = 0, $reps = 0.01, $aeps = 0.01, $line)

C<Cv> の C<FilLine()> は C<$points> で渡された Perl の配列を
C<Cv::Mat> のオブジェクトに変換し、C<Cv::Arr::FitLine()> を呼びます。
C<$points> は 2次元または 3次元の点の配列です。C<$line> は、2次元なら
C<[$vx, $vy, $x0, $y0]> に、3次元なら C<[$vx, $vy, $vz, $x0, $y0,
$z0]> になります。入力の C<$points> と出力の C<$line> 以外のパラメータ
は指定しなければデフォルト値を使います。

例を示します。いくつかの点の集りにフィッティングさせた直線を描きます。

 my $img = Cv::Image->new([250, 250], CV_8UC3)->fill(cvScalarAll(255));
 $img->origin(1);
 my @points = ([ 50, 50 ], [ 100, 120 ], [ 150, 150 ], [ 200, 150 ]);
 Cv->fitLine(\@points, my $line); my ($vx, $vy, $x0, $y0) = @$line;
 $img->line((map { [ $_, $vy / $vx * ($_ - $x0) + $y0 ] } 20, 230),
			cvScalarAll(200), 3, CV_AA);
 $img->circle($_, 3, [200, 200, 255], -1, CV_AA) for @points;
 $img->show;
 Cv->waitKey;

=item Cv::Arr::CvtMatToArray($arr)

 # @array = $arr->cvtMatToArray
 # $arr->cvtMatToArray(\@array)
 # @array = $arr->ToArray

=item Cv::Arr::ToArray($arr)

=item Cv::Seq::Point::CvtSeqToArray($seq)

 # @array = $seq->cvtSeqToArray
 # @array = $seq->cvtSeqToArray($slice)
 # $seq->cvtSeqToArray(\@array)
 # $seq->cvtSeqToArray(\@array, $slice)
 # @array = $seq->ToArray

=item Cv::Seq::Point::ToArray($seq)

=item Cv::FitEllipse2($points)

=item Cv::MinAreaRect2($points)

=item Cv::MinEnclosingCircle($points)

=item Cv::ContourArea($points)

=item Cv::Arr::Affine()

=item Cv::GetBuildInformation()

=item Cv::HasModule()

=back


=head1 バグ

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
