# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - L<Cv|Cv::Nihongo> をもう少し Perl で使いやすくしたいね。

=head1 概要


=head1 説明

C<Cv::More> は、L<Cv|Cv::Nihongo> から実験的な機能を切り離して整理する
ためのパッケージです。C<Cv> が拡張しやすくなると考えています。
C<Cv::More> は、もともと C<Cv> の一部だったので、使わないことを明示しな
い限り C<Cv::More> も取り込まれます。

 use Cv;              # Cv::More を使う
 use Cv qw(:nomore);  # Cv::More を使わない

=head2 Perlの配列を使う

Perl で 2次元の点のリストは、おそらく次のようなものになるでしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV には、こうしたデータを処理する関数がいくつもあります。使用するに
は、このようなリストを OpenCV のマトリクスやシーケンスに変換しなければ
なりません。はじめはこのあたりから C<Cv> を使いやすくするということにつ
いて考えてみましょう。

=over

=item

点のリストを処理する関数は、次のドキュメンテーションの中に、いくつも見
付けられます。

L<http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html>

=back

=head3 Perlの配列でマトリクスを作る

上記の点のリスト C<@pts> をマトリクスのオブジェクトに変換するには、Nx1
のマトリクスを作り、要素を 1つずつ代入します。

 my $mat = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $mat->set([ 0, 0 ], [ $x0, $y0 ]);
 $mat->set([ 1, 0 ], [ $x1, $y1 ]);
 $mat->set([ 2, 0 ], [ $x2, $y2 ]);

これは、C<Cv::Mat-E<gt>new()> にオブジェクトの作成だけでなく、初期値を
設定する機能を持たせて、次のとおり 1つにまとめましょう。大きさは初期値
から分りますが、指定したくなることも考えられるので、省略 (初期値から得
られる大きさを使うということ) を C<[ ]> で示します。

 my $pts = Cv::Mat->new([ ], CV_32FC2,
    [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ],
    );

もうひとつ、大きさ 3x3、要素の型 C<CV_32FC1> のカメラマトリクスを作る例
を示します。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

書き方にもよりますが、代入文を並べるより直感的だと思います。この拡張は、
C<Cv::More> で C<Cv::Mat::new> を再定義して実験し、もし使いやすければ、
他のクラスへの適用も考えることにします。 XXXXX

=head3 マトリクスに要素を代入する

上の L</Perlの配列でマトリクスを作る> と同じように、次の 3x3 のマトリク
スの部分的な更新について考えましょう。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードは要素を 1つずつ代入します。 C<Cv> は、C言語のリファレンスを
そのまま実装したので、要素の代入しか出来ません。要素を修飾するマトリク
スのインデクスは、要素 C<$pts[0]>, C<$pts[1]>, C<$pts[2]> に合わせた
C<[ 2, 0 ]>, C<[ 2, 1 ]>, C<[ 2, 2 ]> になり、少々、冗長です。3行を1行
にまとめましょう。

 $mat->set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->set([ 2 ], \@pts);

すっきりしました。ただ、このインデクスを C<[ 2 ]> と書く表現は、すでに
C<Set()> では少し違う意味で使っています。それは、いまの C<Set()> は省略
したインデクスを単に 0で補うだけのものですが、1次元のリストの表現に 2次
元の C<Cv::Mat> を Nx1 で使ったとき、いつも 0 になるインデクスの省略を
許してくれるのです。具体的には次のとおり。どちらも同じように働きます。

 my $points = Cv::Mat->new([ 3, 1 ], CV_32FC2);
 $points->set([ 2, 0 ], [ $x, $y ]);   # すべてのインデクスを書く
 $points->set([ 2 ], [ $x, $y ]);      # いつも 0 になるインデクスを省略

というわけで、C<[ 2 ]> は C<[ 2, x ]> の要素をまとめた代入先という意味
と、C<[ 2, 0 ]> の 0 の省略という 2つの意味を持つことになります。これは
C<Cv::Mat::new> を再定義する m_set() で詳細を考えましょう。

=head3 Perlの配列とOpenCVのシーケンス

OpenCV には多数の同じ要素を格納するマトリクスと異なる要素を格納するシー
ケンスというデータ構造があります。どちらでも点のリストは表現できます。
少し視点を変えて、OpenCV に用意されているシーケンスの利用について考えて
みましょう。(これはL<Cv::Seq|Cv::Seq-ja> へ)

=head3 マトリクスを Perl の配列に戻す

それでは次に OpenCV のデータを Perl の配列に変換する、戻すということに
ついて考えてみましょう。点を格納した Nx1 のマトリクスから順番に要素を取
り出すためのコードは次のとおり。

 for (my $i = 0; $i < $mat->rows; $i++) {
   my $x = $mat->get([$i, 0]);
   ...
 }

インデクス $i は要素を取り出す場面でしか使われないことが多いので、少し
工夫すれば次のとおり書くことができます。

 for ($mat->ToArray) {
     ...
 }

更に C<@{}> をオーバロードして C<ToArray()> を呼び出せるようにすれば、
Perl の点の配列を扱うところで利用者の負担を減らすことができます。たとえ
ば、点のリストを入力にする C<PolyLine()> では次のとおり。

 $img->polyLine([ [ @$mat ] ], ...); # もっと可能性があると思う。

=head2 メソッドに歩み寄ってもらう

ここまでは、Perl の配列と OpenCV のマトリクスの変換を簡単にして、主に
OpenCV の関数に渡す引数を簡単に作るということを考えてきました。次は、
OpenCV の関数、すなわち C<Cv> のメソッドの方に歩み寄ってもらい、Perl の
点の配列を受け取れるように考えて行きましょう。

=head3 C言語の面影かな

細部について考える前に、点のリストを入力にするメソッドを C<Cv> の実装か
ら集めてみましょう。

 my $rect = Cv->boundingRect(\@points, $update);
 Cv->fitLine(\@points, $dist_type, $param, $reps, $aeps, my $line);
 my $box = Cv->fitEllipse2(\@points);
 my $box = Cv->minAreaRect2(\@points);
 Cv->minEnclosingCircle(\@points, my $center, my $radius);
 my $s = Cv->ContourArea(\@points);

結果を引数で受けとる関数があるのは、結果が複数あるとき戻り値だけで済ま
なかったのでしょう。たとえば、C<MinEnclosingCircle()> は、 $center と
$radius の 2つを返したいが、できなかった。そういう感じです。これは、C言
語の戻り値の制約によるものですが、Perl はそうではありません。次のとおり
書くことができます。

 my ($vx, $vy, $x0, $y0) = Cv->FitLine(\@points, ...);
 my ($center, $radius) = Cv->minEnclosingCircle(\@points);

=head3 歩み寄りの歩み寄り

簡単に、使いやすく、という話は分りますが、いままでに作ったプログラムが
動かなくなるかもしれません。いや、きっと動かなくなるでしょう。迷惑な話
です。

たとえば、MiAreaRect() は、いままで呼び出されたコンテクストに関係なく、
いつでもスカラを返していたので、呼ばれたコンテクストに合わせた戻り値を
返すように、正しいと思う変更を加えるとしましょう。それは、役に立つかも
しれませんが、動いていた MinAreaRect() は動かなくなります。

  Cv->boxPoints(Cv->minAreaRect(\@points));    # いままで動いていたのに
  Cv->boxPoints(scalar Cv->minAreaRect(\@points));  # 少し書き直し ...

簡単にしよう。良くしよう。そう思ったのに、面倒くさいことになってしまい
ました。やはりインターフェースの変更は厄介ですね。というわけで、コンテ
クトに合わせた戻値を使うときには、次のとおり使いたい人がそれを明示した
ときにだけ使えるようにしましょう。

  use Cv::More qw(cs);                 # コンテクトに合った戻値を使う
  use Cv::More qw(cs-warn);            # その前に危いところを調べる

2行目の cs-warn は、コンテクストに合わせた戻値を使うと動かなくなる可能
性のあるところ、つまりリストコンテクストでスカラを返すような場面を実行
時にみつけたときメッセージを出力します。はじめに、2行目の cs-warn で確
認して、その後、1行目の cs を指定することにしましょう。

もし全体でこのような変更を加える場合はいいですが、そうでないときには、
import() と unimport() でごまかすことに、、、

  Cv::More->import(qw(cs));
  Cv::More->unimport(qw(cs));

=head2 追加または拡張したメソッド

=over

=item FitEllipse2()

 my $box2d = Cv->FitEllipse2($points);

戻り値は CvBox2D です。cs のときには、リストコンテクストで呼ばれると、
次のとおり要素が展開されます。

 use Cv::More qw(cs);
 my ($center, $size, $angle) = Cv->FitEllipse2($points);

Perl のリストで表わした点と、それを FitEllipse2() で処理した結果を描き
表示するサンプルを示します。

 my $img = Cv::Image->new([250, 250], CV_8UC3)->fill(cvScalarAll(255));
 $img->origin(1);
 my @pts = (map { [ map { $_ / 4 + rand $_ / 2 } @{$img->size} ] } 1 .. 20);
 $img->circle($_, 3, &color, 1, CV_AA) for @pts;
 my $box = Cv->fitEllipse(\@pts);
 $img->polyLine([[Cv->boxPoints($box)]], -1, &color, 1, CV_AA);
 $img->ellipseBox($box, &color, 1, CV_AA);
 $img->show("FitEllipse2");
 Cv->waitKey;
 sub color { [ map { rand 255 } 1 .. 3 ] }


=item FitLine()

FitLine() には、次の 2つの呼出し形式があります。Perl では (1) の使い方
になると思いますが、OpenCV の C言語のインターフェースに合わせた (2) の
使い方もできます。

 my $line = Cv->FitLine($points, $dist_type, $param, $reps, $aeps);     # (1)
 Cv->FitLine($points, $dist_type, $param, $reps, $aeps, my $line);      # (2)

パラメータはたくさんありますが、$points 以外は省略できます。入力
$points は、2次元の点または 3次元の点のリストで、結果は、この $points
の次元数で決まります。

 my $points2d = [ [$x1, $y1], [$x2, $y2], ... ];
 my ($vx, $vy, $x0, $y0) = Cv->FitLine($points2d, ...);
 my $points3d = [ [$x1, $y1, $z1], [$x2, $y2, $z2], ... ];
 my ($vx, $vy, $vz, $x0, $y0, $z0) = Cv->FitLine($points3d, ...);

いくつかの点の集りにフィッティングさせた直線を描いてみましょう。

 my @pts = ([ 50, 50 ], [ 100, 120 ], [ 150, 150 ], [ 200, 150 ]);
 my ($vx, $vy, $x0, $y0) = Cv->fitLine(\@pts); 
 $img->line((map { [ $_, $vy / $vx * ($_ - $x0) + $y0 ] } 20, 230),
			cvScalarAll(200), 3, CV_AA);

サンプルのはじめと終りは C<FitEllipse2()> を参照してください。


=item MinAreaRect2()

 my $box2d = Cv->MinAreaRect2($points);
 my ($center, $size, $angle) = Cv->MinAreaRect2($points);

戻り値は CvBox2D です。FitEllipse2() と同じような結果を返しますが。重ね
合わせてみると違いが分ります。

 for ([ [ Cv->fitEllipse(\@pts)  ], [ 200, 200, 200 ] ],
      [ [ Cv->minAreaRect(\@pts) ], [ 100, 100, 255 ] ]) {
   $img->polyLine([[Cv->boxPoints($_->[0])]], -1, $_->[1], 1, CV_AA);
   $img->ellipseBox($_->[0], $_->[1], 1, CV_AA);
 }

サンプルのはじめと終りは C<FitEllipse2()> を参照してください。

C言語のインタフェースは次のとおり。メモリストレージを渡すこともできます。

 CvBox2D cvMinAreaRect2(const CvArr* points, CvMemStorage* storage=NULL)

Cv-0.15 までは、Perl の点のリストを Cv::Seq::Point にして使っていました。
そのときはメモリストレージを使うこともできたのですが Cv-0.16 で Perl の
点のリストを Cv::Mat に直したので、メモリストレージを渡しても使いません。


=item MinEnclosingCircle()

 my $circle = Cv->MinEnclosingCircle($points);                          # (1)
 my ($center, $radius) = Cv->MinEnclosingCircle($points);               # (1')
 Cv->MinEnclosingCircle($points, my $center, my $radius);               # (2)

戻り値は、円の中心の座標 $center と半径 $radius です。CvBox2D の形に合
わせて重ね合わせてみましょう。

 my $rectangle = Cv->minAreaRect2(\@pts);
 my $ellipse = Cv->fitEllipse2(\@pts);
 my ($center, $radius) = Cv->minEnclosingCircle(\@pts);
 my $circle = [ $center, [ ($radius * 2) x 2 ], 0 ];
 for ([ $rectangle, [ 200, 200, 200 ] ],
      # [ $ellipse,   [ 200, 200, 200 ] ],
      [ $circle,    [ 100, 100, 255 ] ]) {
   $img->polyLine([[Cv->boxPoints($_->[0])]], -1, $_->[1], 1, CV_AA);
   $img->ellipseBox($_->[0], $_->[1], 1, CV_AA);
 }

サンプルで使った乱数による点のリストを処理してもあまり面白くないかもし
れませね。点が表わすものを C<FitEllipse2()>, C<FitLine()>,
C<MinAreaRect2()>, C<MinEnclosingCircle()> の中から元の形に合うものを選
ぶといいでしょう。サンプルはどれも似ているので、そのはじめと終りは
C<FitEllipse2()> から持って来てください。

(注意) MinEnclosingCircle() の戻り値は、Cv-0.15 まで (1') の形式でした。
つまり、いつも ($center, $radius) を返していました。しかし、Cv-0.16 で
メソッドの戻り値を揃え [$center, $radius] を返すことにしました。

=item BoundingRect()

 my $rect = Cv->BoundingRect($points)
 my ($x, $y, $width, $height) = Cv->BoundingRect($points)

点を囲む傾いていない矩形を求めます。傾いている矩形には
C<MinAreaRect2()> を使います。戻り値は CvRect なので、CvBox2D に直すと
C<EllipseBox()> や C<BoxPoints()> とのつながりが良くなります。
CvRect から CvBox2D への変換は次のとおり。

 my $box2d = [ [ $x + $width / 2, $y + $height / 2 ], [ $width, $height ], 0 ];


=item ToArray()

 my @array = $arr->ToArray();                                           # (1)
 my @array = $arr->ToArray($slice);                                     # (2)

シーケンスまたはマトリクス (1xN, Nx1) を Perl の点の配列に変換します。
シーケンスを変換する cvCvtSeqToArray() をマトリクスを扱えるように、拡張
したものです。$slice は [ $start, $end ] の形式か、cvSlice() が使えます。
マトリクスは、いまのところ C<Cv::Mat> しか扱えません。C<Cv::MatND> も扱
えるといいのかもしれませんが、そのうちに、、、

cvCvtSeqToArray() が元になっているので同じ呼出し形式も使えます。つまり、
次の使い方もできます。でも使わないかもしれませんね。

 $arr->ToArray(\my @array);                                             # (3)
 $arr->ToArray(\my @attay, $slice);                                     # (4)

(注意) Perl の配列のようにインデクスに負数が使えると便利なことがありま
す。私もよく使いますが、いまのところ、そのような使い方はできません。そ
のうち考えてみようと思っています。

 my @array = $arr->ToArray([ -1, 1 ]);
 my @array = $arr->ToArray([ 1, -1 ]);


=item Cv::ContourArea($points)

=item Cv::Arr::Affine()

=item Cv::GetBuildInformation()

=item Cv::HasModule()

=item Cv::Arr::m_new($size, $type, @init)

OpenCV の画像やマトリクスのオブジェクトは、大きさと要素の型を指定して作
ります。C<Cv::Createなんとか()> か C<Cv::なんとか::new()> で作ります。
C<m_new()> は、これらを再定義し、初期値を扱えるように拡張します。

 my $mat1 = Cv::Mat->new([], 要素の型, 初期値のリスト);
 my $mat2 = Cv::Mat->new(マトリクスの大きさ, 要素の型);
 my $mat3 = $mat->new();
 my $mat4 = $mat->new(マトリクスの大きさ);
 my $mat5 = $mat->new(要素の型);

C<m_new()> が拡張するのは、上の C<$mat1> を作る例です。マトリクスの大き
さを指定するところに C<[]> を指定します。具体的な使い方については、
L</Perlの配列でマトリクスを作る> を参照してください。他の例は、いまの
C<Cv> の C<new()> でできます。

初期値は、C<m_set()> で実装されています。制約もあるので詳細を確認してく
ださい。

=item Cv::Arr::m_set($mat, $index, $value)

マトリクスの要素、または要素のまとまりに値を代入します。 C<$index> で指
定されたマトリクスの要素の数と C<$value> で指定された要素の値の数のバラ
ンスがとれるように、C<$index> を補うか C<$value> をばらします。そして、
マトリクスの要素に値を 1つずつ代入します。

=over

=item *

代入される側、すなわちインデクスによる修飾は次のとおり。

 $mat->set([], $value);       # マトリクス $mat 全体
 $mat->set([$i], $value);     # マトリクス $mat の $i 行
 $mat->set([$i, $j], $value); # マトリクス $mat の $i 行 $j 列 

=back

 * 値の数が足りないとき代入を打ち切る。
 * m_set は set を再定義する。
 * m_set は失敗することがある。
 * m_ は Cv::more の〜 から。
 * ec は eval & croak くらい。

XXXXX

C<$mat> の要素を特定するために必要なインデクス (C<$mat> の添字) の数が、
C<$index> の指す配列に格納される要素の数と等しいなら C<$mat> の要素は特
定されたと考えられます。ただ、C<$value> については、C<$mat> の要素のチャ
ネル数が 1 のとき、たとえば C<CV_32FC1> のときにはリファレンスでない
C<$value> を使うことが考えられ、ここでリファレンスに直します。

 $value = [ $value ] unless ref $value;
 cvSetND($mat, $idx, $value)

しかし、こうして C<cvSetND()> を呼んだとき、誤りがあれば OpenCV がエラー
を発生させるでしょう。しかし C<m_set()> は下記のとおり再帰呼出しを使う
ので、エラーを補足するために呼出し側は C<eval { }> を使わなければなりま
せん。

上記の条件を満足しないとき、つまり、C<$mat> の要素を特定するために必要
なインデクスの数が足りないとき、もし C<$value> がネストした配列なら、足
りないインデクスを補って C<$value> の要素を 1つずつ C<m_set()> で再帰的
に処理します。

 $mat->m_set([@$idx, $_], $value->[$_]) for 0 .. $#{$value}

同様に、要素を特定するために必要なインデクスが足りないときは、
C<$value> がネストした配列ではなくても要素の数が 2以上だと混乱します。
もし C<$mat> の要素のチャネル数が 2 以上 (たとえば C<CV_32FC2> の類) な
ら、C<$value> の要素は個々のチャネルに対応するものかもしれないので、
Nx1 のマトリクスの最後のいつも 0 になるインデクス、つまり x1 の部分が省
略されたかもしれません。だから x2 以上で、要素のチャネル数が 1
(C<CV_32FC1> の類) のときにも、上と同様 C<$value> の要素を 1つずつ
C<m_set()> で再帰的に処理します。

それ以外は、最後のいつも 0 になるインデクスが省略された可能性がないか、
更に次のとおりインデクスに 0 を補い、再帰的な要素の更新を試みます。

 $mat->m_set([@$idx, 0], $value);

=back


=head1 バグ

=over

=item *

=back

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
