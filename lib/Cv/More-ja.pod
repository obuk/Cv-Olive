# -*- mode: pod; coding: utf-8; tab-width: 4; -*-
=encoding utf8

=head1 名前

Cv::More - Cv をもう少し Perl で使いやすくする。

=head1 概要


=head1 説明

=head2 Perlの配列を使う

=head3 Perlの配列とOpenCVのマトリクス

(Cv-0.16) 

Perl の配列は柔軟なので、Perl の配列で OpenCV のデータを表わしたくなり
ます。たとえば、2次元の点のリストなら次のとおり書くでしょう。

 my @pts = ( [ $x0, $y0 ], [ $x1, $y1 ], [ $x2, $y2 ] );

OpenCV ではこのような点のリストをマトリクスやシーケンスのデータ型を使っ
て表わします。そこでマトリクスのオブジェクトを作るときに Perl の配列を
初期値として使うことにしました。マトリクスの大きさ [$rows, $cols] は、
Perl の配列なら分るので、次の例のとおり、大きさに相当する引数をには []
空の配列を指定します。

 my $pts = Cv::Mat->new([], CV_32FC2, @pts);

この例で作られる $pts は、大きさが 3x1 で要素の型が CV_32FC2 のマトリク
スです。たとえば、大きさが 3x3 で要素の型が CV_32FC1 のカメラのマトリク
スなら次のとおり書きます。

 my $cmat = Cv::Mat->new([ ], CV_32FC1,
    [ $fx,   0, $cx ],
    [   0, $fy, $cy ],
    [   0,   0,   1 ],
    );

点のリストは、OpenCV で動的なデータ構造を表わすシーケンスでも作ることが
できます。シーケンスの方が Perl のリストに似ています。シーケンスを操作
する関数の名前も Perl に似ています。従って、これらの整合は悪くないと思
います。そういうわけで、C<Cv> の FitLine() や FitEllipse2() は、Perl の
配列をその場でシーケンスに直して使っていました。 OpenCV の関数の中には
マトリクスとシーケンスの両方を扱ってくれる関数がいくつもあるのです。

しかし、シーケンスよりマトリクスの方が形がはっきりしている分だけ分りや
すく、またいまの C<Cv> の実装では処理時間もマトリクスの方に分があります。
というわけで、途中でデータの大きさを変えることがないならシーケンスを使
う理由もなくなり、しばらく 2つの実装を比べてみて、それからどちらを使う
のか考えようと思っています。

=head3 マトリクスへの代入

要素をマトリクスに代入するには set() を使います。インデクスを指定して、
ひとつずつ要素を代入します。

 my $mat = Cv::Mat->new([ 3, 3 ],  CV_32FC2);
 $mat->set([ 2, 0 ], $pts[0]);
 $mat->set([ 2, 1 ], $pts[1]);
 $mat->set([ 2, 2 ], $pts[2]);

このコードにはインデクス [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] が並んでいます。
このような書き方は、しばしば見かけられ、書くのもそう難しくありません。
しかし、多くなると少し苦痛を感じます。もし書けるものなら [ 2 ] と書いて、
値を並べたいところです。たとえば、次のように。

 $mat->m_set([ 2 ], [ $pts[0], $pts[1], $pts[2] ]);
 $mat->m_set([ 2 ], \@pts);

この書き方は、上の C<new> の初期化に合わせたものです。とりあえず、
set() を拡張せず、m_set() という別の名前を使いましたが、先々、set() を
拡張して統合するかもしれません。XXXXX

いまの set() は ptr() に合わせてインデクスの省略を単に 0 として扱ってい
ますが、点のリストをマトリクスに格納して使うときにも都合がいいのです。
点のリストは 1次元ですが、マトリクスは 2次元なので、Nx1 のマトリクスを
使います。Nx1 は、いつも 0 になるインデクスを作るので、省略を 0 にする
と都合が良い、ということになるのです。

 my $points = Cv::Mat->new([3, 1], CV_32FC2);
 $points->set([$i], [$x, $y]);

この例は、[$i, 0] と書くのが正しいのですが、0 を省略して [$i] だけで済
ませています。こうした書き方ができなくなるのです。

=head3 Perlの配列とOpenCVのシーケンス

OpenCV のマトリクスは、多数の同じ要素を格納するデータ構造ですが、異なる
要素を格納するデータ構造もあります。OpenCV のシーケンスは、点、矩形、円
など様々なデータを格納します。Perlの配列に似ていますが、その取り扱いは
少し難しいのです。そこで、格納されたデータ型を意識せずに扱うスーパクラ
ス Cv::Seq と、データ型に合わせて pack/unpack で変換する派生クラス
Cv::Seq::Point, Cv::Seq::Rect を作り、データ型に合わせて bless して使う
ことにしました。C言語のキャストと同様の使い方です。

=head3 シーケンスを使う

以下、facedetect の一部を示します。取り出されるシーケンスは、Perl で扱
いやすい形になります。

  my $faces = bless $image->HaarDetectObjects(
	$cascade, $storage, 1.1, 2, CV_HAAR_SCALE_IMAGE,
	cvSize(30, 30)), "Cv::Seq::Rect";
  while (my @rect = $faces->shift) {
    ...
  }

OpenCV のシーケンスは Perl の配列に似ているので、シーケンスを操作するた
めに、Push(), Pop(), Shift(), Unshift(), Splice() も用意しました。
点のシーケンス Cv::Seq::Point はよく使うので、new もあります。次の例は、
Perl の点の配列をシーケンスに直して MinEnclosingCircle() を呼びます。
$center と $radius が求まります。

 my @points = ([ 100, 100 ], [ 100, 200 ], [ 200, 100 ]);
 Cv::Seq::Point->new(&Cv::CV_32SC2)->push(@points)
	->minEnclosingCircle(my $center, my $radius);

同様に FitLine() でも Perl の配列を使うことができます。(Cv-0.15)

 Cv->FitLine(\@points, my $line);

ToArray() は、シーケンスを Perl の配列に変換します。次のコードは、
シーケンス $circles に格納されたすべての円を描きます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for $circles->toArray;

ToArray() でオーバライドされた @{} を使うと、もう少し簡単に書けます。

 $img->circle($_->[0], $_->[1], CV_RGB(0, 255, 0), 3)
	for @$circles;


=head1 バグ

=head1 参考

L<Cv::Nihongo|Cv::Nihongo>

=head1 著作権

Yuta MASUDA E<lt>yuta.masuda@newdaysys.co.jpE<gt>

Copyright (c) 2010, 2011, 2012 by Yuta MASUDA.

All rights reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
